"""
Tests for thread support in the Slack webhook handler.
"""

import json
import pytest
from unittest.mock import patch, MagicMock
from django.test import RequestFactory
from django.http import HttpResponse, JsonResponse

from konveyor.apps.bot.views import slack_webhook, process_message


@pytest.mark.django_db
def test_thread_support():
    """Test that thread_ts is correctly extracted and used."""
    # Create a request factory
    factory = RequestFactory()

    # Mock the SlackService
    with patch("konveyor.apps.bot.views.slack_service") as mock_slack_service, patch(
        "konveyor.apps.bot.views.process_message"
    ) as mock_process_message:

        # Set up the mocks
        mock_slack_service.verify_request.return_value = True
        mock_slack_service.send_direct_message.return_value = {"ok": True}
        mock_slack_service.send_message.return_value = {"ok": True}

        mock_process_message.return_value = {
            "response": "Test response",
            "skill_name": "ChatSkill",
            "conversation_id": "test_conversation_id",
            "success": True,
            "thread_ts": "1234567890.123456",  # Include thread_ts in the response
        }

        # Test event callback with threaded message
        post_data = {
            "type": "event_callback",
            "event_id": "test_event_id",
            "api_app_id": "test_app_id",
            "event": {
                "type": "message",
                "user": "test_user",
                "text": "Hello, world!",
                "channel": "test_channel",
                "channel_type": "channel",
                "ts": "1234567890.123456",
                "thread_ts": "1234567890.123456",  # This is a threaded message
                "client_msg_id": "test_client_msg_id",
            },
        }
        post_request = factory.post(
            "/api/bot/slack/events/",
            data=json.dumps(post_data),
            content_type="application/json",
        )
        response = slack_webhook(post_request)

        # Verify the response
        assert response is not None
        assert isinstance(response, HttpResponse)
        assert response.status_code == 200

        # Verify process_message was called with thread_ts
        mock_process_message.assert_called_once_with(
            "Hello, world!",
            "test_user",
            "test_channel",
            "1234567890.123456",  # thread_ts should be passed
        )

        # Verify send_message was called with thread_ts
        # We don't check the exact blocks since they're generated by the formatter
        assert mock_slack_service.send_message.call_count == 1
        call_args = mock_slack_service.send_message.call_args
        assert call_args[0][0] == "test_channel"  # channel
        assert call_args[0][1] == "Test response"  # text
        assert call_args[1]["thread_ts"] == "1234567890.123456"  # thread_ts


def test_process_message_with_thread():
    """Test that process_message includes thread_ts in the result."""
    # Mock the orchestrator
    with patch("konveyor.apps.bot.views.orchestrator") as mock_orchestrator:
        # Set up the mock
        mock_orchestrator.process_request_sync.return_value = {
            "response": "Test response",
            "skill_name": "ChatSkill",
            "function_name": "answer",
            "success": True,
        }

        # Call process_message with thread_ts
        result = process_message(
            "Hello, world!",
            "test_user",
            "test_channel",
            "1234567890.123456",  # Include thread_ts
        )

        # Verify thread_ts is included in the result
        assert result is not None
        assert "thread_ts" in result
        assert result["thread_ts"] == "1234567890.123456"

        # Verify thread_ts is included in the context passed to orchestrator
        context = mock_orchestrator.process_request_sync.call_args[0][1]
        assert "thread_ts" in context
        assert context["thread_ts"] == "1234567890.123456"
