name: "Code Quality Checks"

permissions:
  contents: read   # Required for checkout
  id-token: write  # Required for Azure login
  actions: read    # Required for workflow calls
  pages: write     # Required for GitHub Pages deployment

on:
  workflow_dispatch:
    inputs:
      test_type:
        description: 'Type of tests to run'
        required: false
        default: 'mock'
        type: choice
        options:
          - mock
          - real
          - both
      environment:
        description: 'Environment to run tests in'
        required: false
        default: 'test'
        type: choice
        options:
          - dev
          - test
          - prod
      deploy_infrastructure:
        description: 'Whether to deploy infrastructure'
        required: false
        default: 'auto'
        type: choice
        options:
          - auto
          - always
          - never
  workflow_call:
    inputs:
      test_type:
        description: 'Type of tests to run'
        required: false
        default: 'mock'
        type: string
      environment:
        description: 'Environment to run tests in'
        required: false
        default: 'test'
        type: string
      image_tag:
        description: 'Docker image tag to use'
        required: false
        default: 'latest'
        type: string
    secrets:
      AZURE_CREDENTIALS:
        description: 'Azure credentials for authentication'
        required: false

jobs:
  resource-cleanup:
    name: "Clean up soft-deleted resources"
    uses: ./.github/workflows/resource-cleanup.yml
    with:
      environment: ${{ github.event.inputs.environment || 'test' }}
      resource_group: ${{ format('konveyor-{0}-rg', github.event.inputs.environment || 'test') }}
    secrets:
      AZURE_CREDENTIALS: ${{ secrets.AZURE_CREDENTIALS }}

  lint:
    name: Lint Python Code
    runs-on: ubuntu-latest
    timeout-minutes: 25

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch all history for all branches and tags

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'
          cache: 'pip'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install ruff mypy pre-commit

      - name: Run pre-commit hooks
        run: |
          pre-commit run --all-files
        continue-on-error: false  # Make pre-commit checks required

      - name: Check code with Ruff (linting)
        run: |
          ruff check konveyor tests
        continue-on-error: false  # Make Ruff checks required

      - name: Check code with Ruff (formatting)
        run: |
          ruff format --check konveyor tests
        continue-on-error: false  # Make Ruff format checks required


  test-coverage:
    name: Test Coverage
    runs-on: ubuntu-latest
    timeout-minutes: 25
    needs: resource-cleanup

    env:
      DJANGO_SETTINGS_MODULE: konveyor.settings.test
      PYTHONPATH: ${{ github.workspace }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch all history for all branches and tags

      - name: Debug repository contents
        run: |
          echo "Current directory: $(pwd)"
          echo "Repository contents:"
          ls -la
          echo "Konveyor-infra directory:"
          ls -la Konveyor-infra || echo "Konveyor-infra directory not found"
          echo "Git status:"
          git status

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'
          cache: 'pip'

      # Set default parameters based on context
      - name: Set default parameters
        id: defaults
        run: |
          # Initialize with base defaults for feature branches/other pushes
          TEST_TYPE="mock"
          ENVIRONMENT="test" # Default environment for mock, can be overridden
          DEPLOY_INFRA="auto"  # For mock on feature branches, infra deployment should be skipped by later conditions

          # Override for PRs
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            if [[ "${{ github.base_ref }}" == "main" || "${{ github.base_ref }}" == "dev" ]]; then
              # PR to main or dev - use REAL tests in TEST env
              TEST_TYPE="real"
              ENVIRONMENT="test"
              DEPLOY_INFRA="auto" # Real tests in test env might need infra
            fi
          # Override for pushes to main or dev
          elif [[ "${{ github.event_name }}" == "push" ]]; then
            if [[ "${{ github.ref }}" == "refs/heads/main" || "${{ github.ref }}" == "refs/heads/dev" ]]; then
              # Push to main or dev - use REAL tests in TEST env
              TEST_TYPE="real"
              ENVIRONMENT="test"
              DEPLOY_INFRA="auto" # Real tests in test env might need infra
            fi
          fi

          # Override with workflow inputs if they exist (for workflow_dispatch/workflow_call)
          if [[ "${{ github.event.inputs.test_type }}" != "" ]]; then
            TEST_TYPE="${{ github.event.inputs.test_type }}"
          elif [[ "${{ inputs.test_type }}" != "" ]]; then
            TEST_TYPE="${{ inputs.test_type }}"
          fi

          if [[ "${{ github.event.inputs.environment }}" != "" ]]; then
            ENVIRONMENT="${{ github.event.inputs.environment }}"
          elif [[ "${{ inputs.environment }}" != "" ]]; then
            ENVIRONMENT="${{ inputs.environment }}"
          fi

          if [[ "${{ github.event.inputs.deploy_infrastructure }}" != "" ]]; then
            DEPLOY_INFRA="${{ github.event.inputs.deploy_infrastructure }}"
          fi

          # Set outputs for use in conditions
          echo "test_type=${TEST_TYPE}" >> $GITHUB_OUTPUT
          echo "environment=${ENVIRONMENT}" >> $GITHUB_OUTPUT
          echo "deploy_infra=${DEPLOY_INFRA}" >> $GITHUB_OUTPUT

          # Set environment variables for use in steps
          echo "TEST_TYPE=${TEST_TYPE}" >> $GITHUB_ENV
          echo "ENVIRONMENT=${ENVIRONMENT}" >> $GITHUB_ENV
          echo "DEPLOY_INFRA=${DEPLOY_INFRA}" >> $GITHUB_ENV

          echo "Using TEST_TYPE: ${TEST_TYPE}"
          echo "Using ENVIRONMENT: ${ENVIRONMENT}"
          echo "Using DEPLOY_INFRA: ${DEPLOY_INFRA}"

      # Azure Login for real tests
      - name: Debug Azure Credentials
        run: |
          echo "Event name: ${{ github.event_name }}"
          echo "Test type: ${{ env.TEST_TYPE || 'not specified' }}"
          echo "Has AZURE_CREDENTIALS secret: ${{ secrets.AZURE_CREDENTIALS != '' }}"

          # Print the structure of the AZURE_CREDENTIALS (without revealing sensitive values)
          if [[ "${{ secrets.AZURE_CREDENTIALS }}" != "" ]]; then
            echo "AZURE_CREDENTIALS structure:"
            # Extract keys from the JSON without showing values
            echo "${{ secrets.AZURE_CREDENTIALS }}" | grep -o '"[^"\"]*":' | tr -d '":' | sort
          fi

      # Create a dummy Azure credentials file if the secret is missing
      - name: Check Azure Credentials
        if: ${{ github.event_name == 'push' || github.event_name == 'pull_request' || env.TEST_TYPE == 'real' || contains(env.TEST_TYPE, 'both') }}
        id: check-azure-creds
        run: |
          if [[ -n "${{ secrets.AZURE_CREDENTIALS }}" ]]; then
            echo "has_credentials=true" >> $GITHUB_OUTPUT
          else
            echo "has_credentials=false" >> $GITHUB_OUTPUT
            echo "::warning::AZURE_CREDENTIALS secret is missing. Creating a dummy credentials file for testing."
            # Create a dummy credentials file
            echo '{"clientId":"dummy-client-id","clientSecret":"dummy-client-secret","subscriptionId":"dummy-subscription-id","tenantId":"dummy-tenant-id"}' > azure-credentials.json
            # Set the AZURE_CREDENTIALS environment variable
            echo "AZURE_CREDENTIALS_JSON=$(cat azure-credentials.json)" >> $GITHUB_ENV
          fi

      - name: Azure Login
        # Always run Azure login for PR and push events, or when real tests are specified
        id: azure-login
        if: ${{ github.event_name == 'push' || github.event_name == 'pull_request' || env.TEST_TYPE == 'real' || contains(env.TEST_TYPE, 'both') }}
        uses: azure/login@v2.1.0
        with:
          creds: ${{ steps.check-azure-creds.outputs.has_credentials == 'true' && secrets.AZURE_CREDENTIALS || env.AZURE_CREDENTIALS_JSON }}
        continue-on-error: true

      # Report login status
      - name: Report Azure Login Status
        if: ${{ github.event_name == 'push' || github.event_name == 'pull_request' || env.TEST_TYPE == 'real' || contains(env.TEST_TYPE, 'both') }}
        run: |
          if [[ "${{ steps.azure-login.outcome }}" == "success" ]]; then
            echo "✅ Azure login succeeded"
          else
            echo "❌ Azure login failed"
          fi

      - name: Set Terraform Auth Variables
        if: steps.azure-login.outcome == 'success'
        run: |
          echo "Setting Terraform ARM environment variables for Service Principal auth..."
          echo "ARM_CLIENT_ID=${{ secrets.AZURE_CLIENT_ID || fromJson(secrets.AZURE_CREDENTIALS).clientId }}" >> $GITHUB_ENV
          echo "ARM_CLIENT_SECRET=${{ secrets.AZURE_CLIENT_SECRET || fromJson(secrets.AZURE_CREDENTIALS).clientSecret }}" >> $GITHUB_ENV
          echo "ARM_SUBSCRIPTION_ID=${{ secrets.AZURE_SUBSCRIPTION_ID || fromJson(secrets.AZURE_CREDENTIALS).subscriptionId }}" >> $GITHUB_ENV
          echo "ARM_TENANT_ID=${{ secrets.AZURE_TENANT_ID || fromJson(secrets.AZURE_CREDENTIALS).tenantId }}" >> $GITHUB_ENV
          echo "ARM_USE_AZUREAD=true" >> $GITHUB_ENV # Ensures Azure AD based auth is used.

      # Update Terraform setup condition
      - name: Set up Terraform
        if: >-
          ${{
            steps.azure-login.outcome == 'success' &&
            (env.DEPLOY_INFRA == 'always' ||
            (env.DEPLOY_INFRA == 'auto' &&
             (env.TEST_TYPE == 'real' || env.TEST_TYPE == 'both') &&
             (env.ENVIRONMENT == 'test' || env.ENVIRONMENT == 'prod')))
          }}
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: '1.5.7'

      # Update Deploy Infrastructure condition
      - name: Deploy Infrastructure
        if: >-
          ${{
            steps.azure-login.outcome == 'success' &&
            (env.DEPLOY_INFRA == 'always' ||
            (env.DEPLOY_INFRA == 'auto' &&
             (env.TEST_TYPE == 'real' || env.TEST_TYPE == 'both') &&
             (env.ENVIRONMENT == 'test' || env.ENVIRONMENT == 'prod')))
          }}
        id: deploy-infra
        run: |
          # Check if Konveyor-infra directory exists (case-insensitive)
          if [ ! -d "Konveyor-infra" ] && [ ! -d "konveyor-infra" ]; then
            echo "::warning::Konveyor-infra directory not found (checked both cases). Skipping infrastructure deployment."
            # Debug: List all directories to see what's available
            echo "Available directories:"
            ls -la
            # Set mock values for Azure services
            echo "AZURE_SEARCH_ENDPOINT=https://mock-search-endpoint.search.windows.net" >> $GITHUB_ENV
            echo "AZURE_COGNITIVE_SEARCH_ENDPOINT=https://mock-search-endpoint.search.windows.net" >> $GITHUB_ENV
            echo "AZURE_SEARCH_API_KEY=mock-search-api-key" >> $GITHUB_ENV
            echo "AZURE_OPENAI_ENDPOINT=https://mock-openai-endpoint.openai.azure.com" >> $GITHUB_ENV
            echo "AZURE_OPENAI_API_KEY=mock-openai-api-key" >> $GITHUB_ENV
            echo "AZURE_OPENAI_EMBEDDING_DEPLOYMENT=text-embedding-ada-002" >> $GITHUB_ENV
            echo "AZURE_DOCUMENT_INTELLIGENCE_ENDPOINT=https://mock-docint-endpoint.cognitiveservices.azure.com" >> $GITHUB_ENV
            echo "AZURE_DOCUMENT_INTELLIGENCE_API_KEY=mock-docint-api-key" >> $GITHUB_ENV
            echo "AZURE_STORAGE_CONNECTION_STRING=DefaultEndpointsProtocol=https;AccountName=mockaccount;AccountKey=mock-key;EndpointSuffix=core.windows.net" >> $GITHUB_ENV
            exit 0
          fi

          # Check if the environment directory exists (case-insensitive)
          INFRA_DIR="Konveyor-infra"
          if [ ! -d "$INFRA_DIR" ] && [ -d "konveyor-infra" ]; then
            INFRA_DIR="konveyor-infra"
          fi
          ENV_DIR="$INFRA_DIR/environments/${{ github.event.inputs.environment || 'test' }}"
          if [ ! -d "$ENV_DIR" ]; then
            echo "::warning::Environment directory $ENV_DIR not found. Skipping infrastructure deployment."
            # Debug: List available environments
            echo "Available environments:"
            ls -la $INFRA_DIR/environments/ || echo "No environments directory found"
            # Set mock values for Azure services
            echo "AZURE_SEARCH_ENDPOINT=https://mock-search-endpoint.search.windows.net" >> $GITHUB_ENV
            echo "AZURE_COGNITIVE_SEARCH_ENDPOINT=https://mock-search-endpoint.search.windows.net" >> $GITHUB_ENV
            echo "AZURE_SEARCH_API_KEY=mock-search-api-key" >> $GITHUB_ENV
            echo "AZURE_OPENAI_ENDPOINT=https://mock-openai-endpoint.openai.azure.com" >> $GITHUB_ENV
            echo "AZURE_OPENAI_API_KEY=mock-openai-api-key" >> $GITHUB_ENV
            echo "AZURE_OPENAI_EMBEDDING_DEPLOYMENT=text-embedding-ada-002" >> $GITHUB_ENV
            echo "AZURE_DOCUMENT_INTELLIGENCE_ENDPOINT=https://mock-docint-endpoint.cognitiveservices.azure.com" >> $GITHUB_ENV
            echo "AZURE_DOCUMENT_INTELLIGENCE_API_KEY=mock-docint-api-key" >> $GITHUB_ENV
            echo "AZURE_STORAGE_CONNECTION_STRING=DefaultEndpointsProtocol=https;AccountName=mockaccount;AccountKey=mock-key;EndpointSuffix=core.windows.net" >> $GITHUB_ENV
            exit 0
          fi

          # Try to deploy infrastructure
          echo "Using infrastructure directory: $INFRA_DIR"
          echo "Using environment directory: $ENV_DIR"
          cd $ENV_DIR
          # Set environment variable for easier reference
          ENVIRONMENT="${{ github.event.inputs.environment || 'test' }}"

          # Resource cleanup is now handled by a separate job

          # Initialize Terraform with remote backend for state persistence
          terraform init \
            -backend=true \
            -backend-config="resource_group_name=terraform-state-rg" \
            -backend-config="storage_account_name=konveyortfstate" \
            -backend-config="container_name=tfstate" \
            -input=false

          # Select Workspaces for testing
          terraform workspace select integration-test || terraform workspace new integration-test

          # Check if terraform init succeeded
          if [ $? -ne 0 ]; then
            echo "::warning::Terraform init failed. Skipping infrastructure deployment."
            # Set mock values for Azure services
            echo "AZURE_SEARCH_ENDPOINT=https://mock-search-endpoint.search.windows.net" >> $GITHUB_ENV
            echo "AZURE_COGNITIVE_SEARCH_ENDPOINT=https://mock-search-endpoint.search.windows.net" >> $GITHUB_ENV
            echo "AZURE_SEARCH_API_KEY=mock-search-api-key" >> $GITHUB_ENV
            echo "AZURE_OPENAI_ENDPOINT=https://mock-openai-endpoint.openai.azure.com" >> $GITHUB_ENV
            echo "AZURE_OPENAI_API_KEY=mock-openai-api-key" >> $GITHUB_ENV
            echo "AZURE_OPENAI_EMBEDDING_DEPLOYMENT=text-embedding-ada-002" >> $GITHUB_ENV
            echo "AZURE_DOCUMENT_INTELLIGENCE_ENDPOINT=https://mock-docint-endpoint.cognitiveservices.azure.com" >> $GITHUB_ENV
            echo "AZURE_DOCUMENT_INTELLIGENCE_API_KEY=mock-docint-api-key" >> $GITHUB_ENV
            echo "AZURE_STORAGE_CONNECTION_STRING=DefaultEndpointsProtocol=https;AccountName=mockaccount;AccountKey=mock-key;EndpointSuffix=core.windows.net" >> $GITHUB_ENV
            exit 0
          fi

          # Create terraform.tfvars file securely using GitHub Secrets
          # This approach prevents secrets from being exposed in logs
          cat > terraform.tfvars << 'EOF'
          microsoft_app_id="${{ secrets.TF_VAR_MICROSOFT_APP_ID || 'c8218a52-681c-4df2-b558-5fa8e5067b43' }}"
          microsoft_app_password="${{ secrets.TF_VAR_MICROSOFT_APP_PASSWORD }}"
          slack_bot_token="${{ secrets.TF_VAR_SLACK_BOT_TOKEN }}"
          slack_app_token="${{ secrets.TF_VAR_SLACK_APP_TOKEN }}"
          slack_signing_secret="${{ secrets.TF_VAR_SLACK_SIGNING_SECRET }}"
          slack_client_id="${{ secrets.TF_VAR_SLACK_CLIENT_ID }}"
          slack_client_secret="${{ secrets.TF_VAR_SLACK_CLIENT_SECRET }}"
          slack_test_channel_id="${{ secrets.TF_VAR_SLACK_TEST_CHANNEL_ID || 'D08KQ0WPGR2' }}"
          GHCR_PAT="${{ secrets.GHCR_PAT }}"
          DJANGO_SECRET_KEY="${{ secrets.DJANGO_SECRET_KEY || 'django-insecure-test-key-for-ci' }}"
          github_repository="${{ github.repository }}"
          docker_registry_username="${{ github.actor }}"
          docker_image_tag="${{ inputs.image_tag || 'latest' }}"
          EOF

          # Debug: Confirm the file was created (without showing contents)
          echo "terraform.tfvars file created successfully"

          terraform validate

          # Use -var-file explicitly to ensure variables are loaded
          terraform plan -var-file=terraform.tfvars -out=tfplan

          # Apply the plan with a timeout to prevent hanging
          if timeout 15m terraform apply -auto-approve tfplan; then
            # Export environment variables for tests
            echo "AZURE_SEARCH_ENDPOINT=$(terraform output -raw cognitive_search_endpoint)" >> $GITHUB_ENV
            echo "AZURE_COGNITIVE_SEARCH_ENDPOINT=$(terraform output -raw cognitive_search_endpoint)" >> $GITHUB_ENV
            echo "AZURE_SEARCH_API_KEY=$(terraform output -raw cognitive_search_primary_key)" >> $GITHUB_ENV
            echo "AZURE_OPENAI_ENDPOINT=$(terraform output -raw openai_endpoint)" >> $GITHUB_ENV
            echo "AZURE_OPENAI_API_KEY=$(terraform output -raw openai_primary_key)" >> $GITHUB_ENV
            echo "AZURE_OPENAI_EMBEDDING_DEPLOYMENT=$(terraform output -raw openai_embeddings_deployment_name)" >> $GITHUB_ENV
            echo "AZURE_DOCUMENT_INTELLIGENCE_ENDPOINT=$(terraform output -raw document_intelligence_endpoint)" >> $GITHUB_ENV
            echo "AZURE_DOCUMENT_INTELLIGENCE_API_KEY=$(terraform output -raw document_intelligence_primary_key)" >> $GITHUB_ENV
            echo "AZURE_STORAGE_CONNECTION_STRING=$(terraform output -raw storage_connection_string)" >> $GITHUB_ENV
          else
            echo "::warning::Terraform apply failed. Using mock values for Azure services."
            # Set mock values for Azure services
            echo "AZURE_SEARCH_ENDPOINT=https://mock-search-endpoint.search.windows.net" >> $GITHUB_ENV
            echo "AZURE_COGNITIVE_SEARCH_ENDPOINT=https://mock-search-endpoint.search.windows.net" >> $GITHUB_ENV
            echo "AZURE_SEARCH_API_KEY=mock-search-api-key" >> $GITHUB_ENV
            echo "AZURE_OPENAI_ENDPOINT=https://mock-openai-endpoint.openai.azure.com" >> $GITHUB_ENV
            echo "AZURE_OPENAI_API_KEY=mock-openai-api-key" >> $GITHUB_ENV
            echo "AZURE_OPENAI_EMBEDDING_DEPLOYMENT=text-embedding-ada-002" >> $GITHUB_ENV
            echo "AZURE_DOCUMENT_INTELLIGENCE_ENDPOINT=https://mock-docint-endpoint.cognitiveservices.azure.com" >> $GITHUB_ENV
            echo "AZURE_DOCUMENT_INTELLIGENCE_API_KEY=mock-docint-api-key" >> $GITHUB_ENV
            echo "AZURE_STORAGE_CONNECTION_STRING=DefaultEndpointsProtocol=https;AccountName=mockaccount;AccountKey=mock-key;EndpointSuffix=core.windows.net" >> $GITHUB_ENV
          fi

      - name: Build Docker image for testing
        run: |
          # Create a .env file with all necessary environment variables
          echo "DJANGO_SETTINGS_MODULE=konveyor.settings.${{ github.event.inputs.environment || 'test' }}" > .env
          echo "DJANGO_DEBUG=False" >> .env
          echo "DJANGO_SECRET_KEY=django-insecure-test-key-for-ci" >> .env
          echo "AZURE_SEARCH_ENDPOINT=${AZURE_SEARCH_ENDPOINT:-https://mock-search-endpoint.search.windows.net}" >> .env
          echo "AZURE_COGNITIVE_SEARCH_ENDPOINT=${AZURE_COGNITIVE_SEARCH_ENDPOINT:-https://mock-search-endpoint.search.windows.net}" >> .env
          echo "AZURE_SEARCH_API_KEY=${AZURE_SEARCH_API_KEY:-mock-search-api-key}" >> .env
          echo "AZURE_SEARCH_INDEX_NAME=konveyor-documents" >> .env
          echo "AZURE_OPENAI_ENDPOINT=${AZURE_OPENAI_ENDPOINT:-https://mock-openai-endpoint.openai.azure.com}" >> .env
          echo "AZURE_OPENAI_API_KEY=${AZURE_OPENAI_API_KEY:-mock-openai-api-key}" >> .env
          echo "AZURE_OPENAI_API_VERSION=2024-05-13" >> .env
          echo "AZURE_OPENAI_CHAT_DEPLOYMENT=gpt-4o" >> .env
          echo "AZURE_OPENAI_EMBEDDING_DEPLOYMENT=${AZURE_OPENAI_EMBEDDING_DEPLOYMENT:-text-embedding-ada-002}" >> .env
          echo "AZURE_DOCUMENT_INTELLIGENCE_ENDPOINT=${AZURE_DOCUMENT_INTELLIGENCE_ENDPOINT:-https://mock-docint-endpoint.cognitiveservices.azure.com}" >> .env
          echo "AZURE_DOCUMENT_INTELLIGENCE_API_KEY=${AZURE_DOCUMENT_INTELLIGENCE_API_KEY:-mock-docint-api-key}" >> .env
          echo "AZURE_STORAGE_CONNECTION_STRING=${AZURE_STORAGE_CONNECTION_STRING:-DefaultEndpointsProtocol=https;AccountName=mockaccount;AccountKey=mock-key;EndpointSuffix=core.windows.net}" >> .env
          echo "AZURE_STORAGE_CONTAINER_NAME=documents" >> .env

          # Build the Docker image with the environment file
          docker build --build-arg DJANGO_SETTINGS_MODULE=konveyor.settings.test -t konveyor-test:latest .

      - name: Run tests with coverage in Docker
        run: |
          mkdir -p tests/results
          mkdir -p coverage
          # Set proper permissions on the results directory
          chmod -R 777 tests/results
          chmod -R 777 coverage

          # Run tests in Docker container with environment file
          # Use a different approach to handle permissions
          docker run --rm \
            --env-file .env \
            -v $(pwd)/tests/results:/app/test-output \
            -v $(pwd)/coverage:/app/coverage-output \
            konveyor-test:latest \
            bash -c "cd /app && mkdir -p /app/tests/results && python -m pytest konveyor --cov=konveyor --cov-report=xml --junitxml=/app/tests/results/results.xml -v; echo 'Pytest exit code: $?'; echo 'Listing /app/tests/results:'; ls -la /app/tests/results; cp -r /app/tests/results/* /app/test-output/ 2>/dev/null || true && cp coverage.xml /app/coverage-output/ 2>/dev/null || true"

      - name: Check coverage report
        run: |
          # Check if coverage file exists
          if [ ! -f "coverage/coverage.xml" ]; then
            echo "::warning::Coverage file not found. Creating an empty file."
            # Create an empty coverage file to prevent the next step from failing
            echo '<?xml version="1.0" ?><coverage version="1.0"></coverage>' > coverage/coverage.xml
          fi

      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v3
        with:
          file: ./coverage/coverage.xml

      # Upload test results as artifacts
      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-results-unit-test
          path: tests/results/**/*.xml
          retention-days: 5

# TODO: Uncomment the following steps and the deploy-report job to enable HTML reports on GitHub Pages.
# TODO: Ensure your pytest command in the 'Run tests with coverage in Docker' step is updated to generate an HTML report,
# TODO: e.g., by adding --html=coverage_report/index.html --self-contained-html
# TODO: Uncomment deploy-report job to deploy reports to GitHub Pages


#      - name: Upload Pages artifact (Coverage Report)
#        if: always()
#        uses: actions/upload-pages-artifact@v3
#        with:
#            path: 'coverage_report' # Assumes pytest-html outputs to coverage_report/index.html


# deploy-report:
#   needs: test-coverage
#   if: always()
#   runs-on: ubuntu-latest
#   permissions:
#     pages: write
#     id-token: write
#   environment:
#     name: github-pages
#     url: ${{ steps.deployment.outputs.page_url }}
#   steps:
#     - name: Deploy to GitHub Pages
#       id: deployment
#       uses: actions/deploy-pages@v4
